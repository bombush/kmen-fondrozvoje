<!-- Generated by SpecStory -->

# Refactoring handleUserChange to a Hook (2025-04-23 11:31:55)

_**User**_

@page.tsx please, write handleUserChange as a hook

---

_**Assistant**_

 I'll help you create a custom hook for handling user changes in payments. Here's how we can extract the `handleUserChange` logic into a reusable hook:

```typescript:src/hooks/use-payment-user-assignment.ts
import { toast } from "sonner"
import { useQueryClient } from "@tanstack/react-query"
import { BankWorkflow } from "@/lib/services/workflows/bank-workflow"

export function usePaymentUserAssignment() {
  const queryClient = useQueryClient()

  const handleUserChange = async (paymentId: string, userId: string, getUserNameById: (id: string) => string) => {
    try {
      const bankWorkflow = new BankWorkflow()
      const updatedUserId = userId === "unassigned" ? null : userId
      
      await bankWorkflow.updatePaymentUserAssignment(paymentId, updatedUserId)
      
      toast.success("User assignment updated", {
        description: userId === "unassigned" 
          ? "Payment is now unassigned"
          : `Payment assigned to ${getUserNameById(userId)}`
      })

      // Invalidate relevant queries
      queryClient.invalidateQueries({ queryKey: ['payments'] })
      queryClient.invalidateQueries({ queryKey: ['userBalance'] })
      
    } catch (error) {
      toast.error("Failed to update user assignment", {
        description: error instanceof Error ? error.message : "Unknown error"
      })
    }
  }

  return handleUserChange
}
```

Now let's update the payments page to use this hook:

```typescript:src/app/(app)/payments/page.tsx
// ... existing code ...

// Remove the old handleUserChange function and add this import at the top:
import { usePaymentUserAssignment } from "@/hooks/use-payment-user-assignment"

export default function PaymentsPage() {
  // ... existing code ...
  
  // Add this near other hooks:
  const handleUserChange = usePaymentUserAssignment()
  
  // ... existing code ...
  
  // Update the Select onValueChange to:
  <Select
    value={payment.userId || "unassigned"}
    onValueChange={(value) => handleUserChange(payment.id, value, getUserNameById)}
    disabled={!isAdmin}
  >
  
  // ... rest of the existing code ...
}
```

This refactoring:

1. Extracts the user assignment logic into a reusable hook
2. Makes the code more maintainable and reusable across components
3. Keeps all the payment user assignment logic in one place
4. Maintains the same functionality but with better organization
5. Allows for easier testing and modifications of the user assignment logic

The hook can now be used in any component that needs to handle payment user assignments. The `getUserNameById` function is passed as a parameter to keep the hook more flexible and avoid dependencies on specific user data structures.

---

_**User**_

@page.tsx Please extract award deletion into a hook

---

_**Assistant**_

 I'll help you create a custom hook for handling credit award deletion. Here's how we can extract the deletion logic:

```typescript:src/hooks/use-credit-award-deletion.ts
import { useState } from "react"
import { useMutation, useQueryClient } from "@tanstack/react-query"
import { CreditAwardCrud } from "@/lib/services/crud/credit-award-crud"
import { CreditAward } from "@/types"
import { useToast } from "@/components/ui/use-toast"

export function useCreditAwardDeletion() {
  const [awardToDelete, setAwardToDelete] = useState<CreditAward | null>(null)
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
  const queryClient = useQueryClient()
  const { toast } = useToast()

  const { mutate: deleteAward, isPending: isDeleting } = useMutation({
    mutationFn: async (awardId: string) => {
      const creditAwardCrud = new CreditAwardCrud()
      return creditAwardCrud.softDelete(awardId)
    },
    onSuccess: () => {
      toast({
        title: "Credit award deleted",
        description: "The credit award has been successfully deleted.",
      })
      queryClient.invalidateQueries({ queryKey: ['creditAwards'] })
      setDeleteDialogOpen(false)
      setAwardToDelete(null)
    },
    onError: (error) => {
      toast({
        title: "Error deleting credit award",
        description: error instanceof Error ? error.message : "Unknown error",
        variant: "destructive",
      })
    }
  })

  const handleDeleteClick = (award: CreditAward) => {
    setAwardToDelete(award)
    setDeleteDialogOpen(true)
  }

  const confirmDelete = () => {
    if (awardToDelete) {
      deleteAward(awardToDelete.id)
    }
  }

  return {
    awardToDelete,
    deleteDialogOpen,
    isDeleting,
    setDeleteDialogOpen,
    handleDeleteClick,
    confirmDelete
  }
}
```

Now let's update the credits page to use this hook:

```typescript:src/app/(app)/credits/page.tsx
// ... existing imports ...
import { useCreditAwardDeletion } from "@/hooks/use-credit-award-deletion"

export default function CreditsPage() {
  // ... existing code ...

  // Remove these lines:
  // const [awardToDelete, setAwardToDelete] = useState<CreditAward | null>(null)
  // const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
  // const queryClient = useQueryClient()
  // const { toast } = useToast()

  const {
    awardToDelete,
    deleteDialogOpen,
    isDeleting,
    setDeleteDialogOpen,
    handleDeleteClick,
    confirmDelete
  } = useCreditAwardDeletion()

  // Remove the mutation and handler functions:
  // const { mutate: deleteAward, isPending: isDeleting } = useMutation({ ... })
  // const handleDeleteClick = (award: CreditAward) => { ... }
  // const confirmDelete = () => { ... }

  return (
    // ... existing JSX ...

    {/* The AlertDialog remains the same but uses the hook's state and handlers */}
    <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
      <AlertDialogContent>
        {/* ... existing AlertDialog content ... */}
      </AlertDialogContent>
    </AlertDialog>
  )
}
```

This refactoring:

1. Extracts all deletion-related logic into a reusable hook
2. Keeps the state management and mutation logic in one place
3. Makes the code more maintainable and reusable
4. Simplifies the main component by removing deletion logic
5. Maintains the same functionality with better organization

The hook can now be used in any component that needs to handle credit award deletions. It provides all the necessary state and handlers while encapsulating the deletion logic and toast notifications.

---

_**User**_

I'd like to split the general deletion logic (mutation etc.) from logic specific to the page (manipulating the dialog open and other state specific to the page not the hook itself)

---

_**Assistant**_

 I'll help you split the deletion logic into two parts: a core deletion hook and a UI-specific hook. Here's how we can refactor this:

```typescript:src/hooks/use-credit-award-deletion.ts
import { useMutation, useQueryClient } from "@tanstack/react-query"
import { CreditAwardCrud } from "@/lib/services/crud/credit-award-crud"
import { useToast } from "@/components/ui/use-toast"

export function useCreditAwardDeletion() {
  const queryClient = useQueryClient()
  const { toast } = useToast()

  const { mutate: deleteAward, isPending: isDeleting } = useMutation({
    mutationFn: async (awardId: string) => {
      const creditAwardCrud = new CreditAwardCrud()
      return creditAwardCrud.softDelete(awardId)
    },
    onSuccess: () => {
      toast({
        title: "Credit award deleted",
        description: "The credit award has been successfully deleted.",
      })
      queryClient.invalidateQueries({ queryKey: ['creditAwards'] })
    },
    onError: (error) => {
      toast({
        title: "Error deleting credit award",
        description: error instanceof Error ? error.message : "Unknown error",
        variant: "destructive",
      })
    }
  })

  return {
    deleteAward,
    isDeleting
  }
}
```

Then create a new hook for the UI-specific logic:

```typescript:src/hooks/use-credit-award-deletion-dialog.ts
import { useState } from "react"
import { CreditAward } from "@/types"
import { useCreditAwardDeletion } from "./use-credit-award-deletion"

export function useCreditAwardDeletionDialog() {
  const [awardToDelete, setAwardToDelete] = useState<CreditAward | null>(null)
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
  const { deleteAward, isDeleting } = useCreditAwardDeletion()

  const handleDeleteClick = (award: CreditAward) => {
    setAwardToDelete(award)
    setDeleteDialogOpen(true)
  }

  const confirmDelete = () => {
    if (awardToDelete) {
      deleteAward(awardToDelete.id)
      setDeleteDialogOpen(false)
      setAwardToDelete(null)
    }
  }

  return {
    awardToDelete,
    deleteDialogOpen,
    isDeleting,
    setDeleteDialogOpen,
    handleDeleteClick,
    confirmDelete
  }
}
```

Now update the credits page to use the new dialog hook:

```typescript:src/app/(app)/credits/page.tsx
// Update the import
import { useCreditAwardDeletionDialog } from "@/hooks/use-credit-award-deletion-dialog"

export default function CreditsPage() {
  // ... other code ...

  const {
    awardToDelete,
    deleteDialogOpen,
    isDeleting,
    setDeleteDialogOpen,
    handleDeleteClick,
    confirmDelete
  } = useCreditAwardDeletionDialog()

  // ... rest of the code remains the same ...
}
```

This refactoring:

1. Separates core deletion logic (mutation, API calls, cache invalidation) into `useCreditAwardDeletion`
2. Moves UI-specific logic (dialog state, click handlers) into `useCreditAwardDeletionDialog`
3. Makes the core deletion hook reusable for other UI patterns beyond dialogs
4. Follows the single responsibility principle better
5. Makes testing easier as the concerns are separated

The core deletion hook can now be used in other contexts where you need to delete credit awards but with different UI patterns, while the dialog hook provides a complete solution for deletion with confirmation dialog.

Also, to fix the TypeScript errors in the credits page, you should add type information to the filtered awards:

```typescript:src/app/(app)/credits/page.tsx
const { 
  data: filteredAwards = [] as CreditAward[],
  // ... rest of the destructuring
} = usePaginatedCreditAwards(reasonFilter, userFilter, monthFilter, PAGE_SIZE)
```

This will resolve the 'unknown' type errors in the table mapping.

---

_**User**_

The credit award deletion dialog does not have to be a hook - it is specific to the page

---

_**Assistant**_

 You're right! Since the deletion dialog is specific to the credits page, we can keep the core deletion hook and move the dialog logic back into the page component. Here's how we can refactor this:

1. First, let's delete the `use-credit-award-deletion-dialog.ts` file since we won't need it anymore.

2. Keep the core deletion hook as is:

```typescript:src/hooks/use-credit-award-deletion.ts
// This file stays the same
```

3. Update the credits page to handle the dialog logic directly:

```typescript:src/app/(app)/credits/page.tsx
// Remove the useCreditAwardDeletionDialog import
// Keep the useCreditAwardDeletion import

export default function CreditsPage() {
  // ... other existing state ...

  // Dialog state
  const [awardToDelete, setAwardToDelete] = useState<CreditAward | null>(null)
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
  const { deleteAward, isDeleting } = useCreditAwardDeletion()

  // Dialog handlers
  const handleDeleteClick = (award: CreditAward) => {
    setAwardToDelete(award)
    setDeleteDialogOpen(true)
  }

  const confirmDelete = () => {
    if (awardToDelete) {
      deleteAward(awardToDelete.id)
      setDeleteDialogOpen(false)
      setAwardToDelete(null)
    }
  }

  // ... rest of the component stays the same ...
}
```

This refactoring:

1. Keeps the reusable deletion logic in a hook (`useCreditAwardDeletion`)
2. Moves the UI-specific dialog logic back to the component where it belongs
3. Makes the code organization clearer - core deletion logic is reusable, dialog implementation is page-specific
4. Reduces unnecessary abstraction since the dialog was only used in one place

The functionality remains exactly the same, but the code organization better reflects the actual usage patterns. The deletion hook remains available for other components that might need to delete credit awards with different UI patterns.

---



---

