<!-- Generated by SpecStory -->

# Using useParams in React Query (2025-03-06 12:23:55)

_**User**_

You said: "Since we're using React Query in a client component, we should use the useParams hook from next/navigation instead of accessing params directly:"

Why is thay so?

---

_**Assistant**_

ðŸ¤–

In Next.js, when you're working with client components, the way you access route parameters can differ from server components. Hereâ€™s why you should use the `useParams` hook from `next/navigation` in client components:

1. **Client-Side Rendering**: Client components are rendered on the client side, meaning they can respond to user interactions and changes in state without needing a full page reload. The `useParams` hook is designed to work seamlessly in this environment, allowing you to access route parameters dynamically.

2. **React Query Integration**: When using React Query, you often want to fetch data based on route parameters. The `useParams` hook provides a straightforward way to access these parameters, ensuring that your data fetching logic can react to changes in the URL.

3. **Consistency**: Using `useParams` keeps your code consistent with the React hooks paradigm, making it easier to manage state and side effects in your components.

4. **Avoiding Direct Access**: Accessing parameters directly (e.g., through `props` or `context`) can lead to issues with reactivity and may not trigger re-renders when the URL changes. The `useParams` hook ensures that your component re-renders appropriately when the parameters change.

In summary, using `useParams` in client components aligns with the React paradigm, enhances reactivity, and simplifies data fetching with libraries like React Query.

---

_**User**_

All read actions should take soft deletion into account. 

---

_**Assistant**_

ðŸ¤–

To implement soft deletion in your read actions, you typically need to modify your queries to filter out any records that have been marked as deleted. This often involves adding a `deleted` or `isDeleted` flag to your data model. Hereâ€™s a general approach to achieve this:

1. **Update Your Data Model**: Ensure your data model includes a field for soft deletion. For example, you might have a boolean field called `isDeleted`.

2. **Modify Your Queries**: When fetching data, add a condition to exclude soft-deleted records. This can be done in your database queries or API calls.

3. **Update Your Read Actions**: Ensure that all read actions (e.g., fetching lists, retrieving single records) respect the soft deletion logic.

Hereâ€™s a simplified example in TypeScript using a hypothetical database query:

```typescript
// Example of a read action that takes soft deletion into account
async function getActiveItems() {
    const items = await db.items.findMany({
        where: {
            isDeleted: false, // Only fetch items that are not soft deleted
        },
    });
    return items;
}
```

### Explanation of Changes:
- **Data Model**: Ensure your data model has an `isDeleted` field.
- **Query Modification**: Update your read queries to filter out soft-deleted records.

If you have specific code or a file you want to modify to implement soft deletion, please share it, and I can help you with the exact changes!

---



---

